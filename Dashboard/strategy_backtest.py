# -------------------------------------------------------------------
# Imports
# -------------------------------------------------------------------

import streamlit as st
import pandas as pd
import inspect
import datetime
from datetime import date
import pickle
import time
from finstore.finstore import Finstore
from strategy.public.ema_strategy import get_ema_signals_wrapper
from strategy.strategy_registry import STRATEGY_REGISTRY
import plotly.graph_objects as go
import numpy as np
import os
from urllib.parse import urlencode
import json

from dotenv import load_dotenv
load_dotenv(dotenv_path='config/.env')

BACKTEST_BACKEND = os.getenv("BACKTEST_BACKEND", "vectorbt").lower()

# üìÅ Directory structure for saving backtests
SAVE_DIR = "saved_backtests"
os.makedirs(SAVE_DIR, exist_ok=True)


# -------------------------------------------------------------------
# Cache functions to load data from Finstore
# -------------------------------------------------------------------
@st.cache_resource
def get_finstore_crypto(timeframe='4h'):
    return Finstore(market_name='crypto_binance', timeframe=timeframe)

@st.cache_resource
def get_finstore_indian_equity(timeframe='1d'):
    return Finstore(market_name='indian_equity', timeframe=timeframe)

@st.cache_resource
def get_finstore(market_name, timeframe, pair=''):
    return Finstore(market_name=market_name, timeframe=timeframe, pair=pair)

# -------------------------------------------------------------------
# Dummy Strategy Functions for Demonstration
# -------------------------------------------------------------------
def list_strategy_modules():
    """Return available strategy modules with their parameters"""
    strategy_dict = {}
    for strategy_name, strategy_details in STRATEGY_REGISTRY.items():
        strategy_dict[strategy_name] = strategy_details['class']

    return strategy_dict


def dummy_rsi_strategy(ohlcv_data, symbol_list, rsi_period=14, oversold=30, overbought=70):
    return pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame()

def dummy_macd_strategy(ohlcv_data, symbol_list, fast=12, slow=26, signal=9):
    return pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame()

# -------------------------------------------------------------------
# Asset Selection Helpers
# -------------------------------------------------------------------
def handle_crypto_selection(crypto_data):
    """Clean crypto selection with pair type filtering and search"""
    col1, col2 = st.columns([1, 3])
    
    with col1:
        pair_type = st.radio(
            "Pair Type:",
            options=["USDT", "BTC"],
            horizontal=True,
            help="Filter by trading pair type"
        )
        
    with col2:
        symbols = crypto_data.get(f"{pair_type} Pairs", [])
        search_query = st.text_input("Search crypto pairs:", key="crypto_search")
        filtered = [s for s in symbols if search_query.lower() in s.lower()]
        
        # Batch operations
        col1, col2 = st.columns(2)
        with col1:
            if st.button(f"Add all {pair_type} pairs", help="Add all filtered pairs"):
                add_symbols(filtered)
        with col2:
            if st.button(f"Clear {pair_type} selection", help="Remove all pairs of this type"):
                remove_symbols(filtered)
        
        # Symbol selection
        selected = st.multiselect(
            "Available pairs:",
            options=filtered,
            default=[s for s in filtered if s in st.session_state.selected_symbols],
            label_visibility="collapsed"
        )
        update_selection(selected, filtered)

def handle_equity_selection(indian_data, us_data):
    """Equity market selection with country grouping"""
    country = st.radio(
        "Market Region:",
        options=["India", "US"],
        horizontal=True
    )
    
    symbols = indian_data.get('NSE Equity', []) if country == "India" \
        else us_data.get('NASDAQ', []) + us_data.get('NYSE', [])
    
    search_query = st.text_input(f"Search {country} equities:", key=f"equity_search_{country}")
    filtered = [s for s in symbols if search_query.lower() in s.lower()]
    
    # Batch operations
    col1, col2 = st.columns(2)
    with col1:
        if st.button(f"Select all {country}"):
            add_symbols(filtered)
    with col2:
        if st.button(f"Clear {country}"):
            remove_symbols(filtered)
    
    # Symbol selection
    selected = st.multiselect(
        f"Select {country} equities:",
        options=filtered,
        default=[s for s in filtered if s in st.session_state.selected_symbols],
        label_visibility="collapsed"
    )
    update_selection(selected, filtered)

def handle_other_selection(commodities_data):
    """Commodities and other markets selection"""
    search_query = st.text_input("Search commodities:", key="comm_search")
    symbols = commodities_data.get('Metals', []) + commodities_data.get('Energy', [])
    filtered = [s for s in symbols if search_query.lower() in s.lower()]
    
    # Batch operations
    col1, col2 = st.columns(2)
    with col1:
        if st.button("Select all commodities"):
            add_symbols(filtered)
    with col2:
        if st.button("Clear commodities"):
            remove_symbols(filtered)
    
    # Symbol selection
    selected = st.multiselect(
        "Select commodities:",
        options=filtered,
        default=[s for s in filtered if s in st.session_state.selected_symbols],
        label_visibility="collapsed"
    )
    update_selection(selected, filtered)


# -------------------------------------------------------------------
# Enhanced Asset Selection Components
# -------------------------------------------------------------------
def crypto_selection_widget(crypto_data):
    st.subheader("üí∞ Crypto Asset Selection")
    col1, col2 = st.columns([1, 3])
    
    with col1:
        pair_type = st.radio("Pair Type:", ["USDT", "BTC"], horizontal=True)
    
    with col2:
        symbols = crypto_data.get(f"{pair_type} Pairs", [])
        search_query = st.text_input("Search pairs:", key=f"crypto_search_{pair_type}")
        filtered = [s for s in symbols if search_query.lower() in s.lower()]
        
        col_a, col_b = st.columns(2)
        with col_a:
            if st.button(f"Add all {pair_type}", help="Add all filtered pairs"):
                add_symbols(filtered)
        with col_b:
            if st.button(f"Clear {pair_type}", help="Clear current selection"):
                remove_symbols(filtered)
        
        # Virtualized selection
        container = st.container()
        selected = container.multiselect(
            f"Select {pair_type} pairs:",
            options=filtered,
            default=[s for s in filtered if s in st.session_state.selected_symbols],
            label_visibility="collapsed"
        )
        update_selection(selected, filtered)

def equity_selection_widget(indian_data, us_data):
    st.subheader("üìà Equity Selection")
    country = st.radio("Market Region:", ["India", "US"], horizontal=True)
    
    symbols = indian_data.get('NSE Equity', []) if country == "India" \
        else us_data.get('NASDAQ', []) + us_data.get('NYSE', [])
    
    search_query = st.text_input(f"Search {country} equities:", key=f"equity_search_{country}")
    filtered = [s for s in symbols if search_query.lower() in s.lower()]
    
    col1, col2 = st.columns(2)
    with col1:
        if st.button(f"Add all {country}"):
            add_symbols(filtered)
    with col2:
        if st.button(f"Clear {country}"):
            remove_symbols(filtered)
    
    container = st.container()
    selected = container.multiselect(
        f"Select {country} equities:",
        options=filtered,
        default=[s for s in filtered if s in st.session_state.selected_symbols],
        label_visibility="collapsed"
    )
    update_selection(selected, filtered)

def commodity_selection_widget(commodities_data):
    st.subheader("üõ¢Ô∏è Commodity Selection")
    search_query = st.text_input("Search commodities:", key="comm_search")
    symbols = commodities_data.get('Metals', []) + commodities_data.get('Energy', [])
    filtered = [s for s in symbols if search_query.lower() in s.lower()]
    
    col1, col2 = st.columns(2)
    with col1:
        if st.button("Add all commodities"):
            add_symbols(filtered)
    with col2:
        if st.button("Clear commodities"):
            remove_symbols(filtered)
    
    container = st.container()
    selected = container.multiselect(
        "Select commodities:",
        options=filtered,
        default=[s for s in filtered if s in st.session_state.selected_symbols],
        label_visibility="collapsed"
    )
    update_selection(selected, filtered)

def mt5_forex_selection_widget(forex_data):
    st.subheader("üí± MT5 Forex Selection")
    
    col1, col2 = st.columns([1, 3])
    
    with col1:
        pair_type = st.radio("Pair Type:", ["Major Pairs", "All Forex"], horizontal=True, key="mt5_forex_type")
    
    with col2:
        symbols = forex_data.get(pair_type, [])
        search_query = st.text_input("Search forex pairs:", key="mt5_forex_search")
        filtered = [s for s in symbols if search_query.lower() in s.lower()]
        
        col_a, col_b = st.columns(2)
        with col_a:
            if st.button("Add all forex", help="Add all filtered forex pairs", key="add_all_forex"):
                add_symbols(filtered)
        with col_b:
            if st.button("Clear forex", help="Clear forex selection", key="clear_forex"):
                remove_symbols(filtered)
        
        container = st.container()
        selected = container.multiselect(
            f"Select {pair_type.lower()}:",
            options=filtered,
            default=[s for s in filtered if s in st.session_state.selected_symbols],
            label_visibility="collapsed",
            key="mt5_forex_multiselect"
        )
        update_selection(selected, filtered)

def mt5_metals_selection_widget(metals_data):
    st.subheader("ü•á MT5 Metals & Indices Selection")
    
    col1, col2 = st.columns([1, 3])
    
    with col1:
        asset_type = st.radio("Asset Type:", ["Precious Metals", "Indices"], horizontal=True, key="mt5_metals_type")
    
    with col2:
        symbols = metals_data.get(asset_type, [])
        search_query = st.text_input("Search assets:", key="mt5_metals_search")
        filtered = [s for s in symbols if search_query.lower() in s.lower()]
        
        col_a, col_b = st.columns(2)
        with col_a:
            if st.button(f"Add all {asset_type.lower()}", help=f"Add all filtered {asset_type.lower()}", key="add_all_metals"):
                add_symbols(filtered)
        with col_b:
            if st.button(f"Clear {asset_type.lower()}", help=f"Clear {asset_type.lower()} selection", key="clear_metals"):
                remove_symbols(filtered)
        
        container = st.container()
        selected = container.multiselect(
            f"Select {asset_type.lower()}:",
            options=filtered,
            default=[s for s in filtered if s in st.session_state.selected_symbols],
            label_visibility="collapsed",
            key="mt5_metals_multiselect"
        )
        update_selection(selected, filtered)


def display_selected_symbols():
    """Clean display of selected symbols"""
    selected = st.session_state.selected_symbols
    st.write(f"**Selected Assets:** {len(selected)}")
    
    if selected:
        # Show first 3 symbols + count of remaining
        display_text = ", ".join(selected[:3])
        if len(selected) > 3:
            display_text += f" (+{len(selected)-3} more)"
        st.caption(display_text)
        
        if st.button("Clear all selections", type="primary"):
            st.session_state.selected_symbols = []

def add_symbols(symbols):
    st.session_state.selected_symbols = list(set(st.session_state.selected_symbols + symbols))

def remove_symbols(symbols):
    st.session_state.selected_symbols = [s for s in st.session_state.selected_symbols if s not in symbols]

def update_selection(selected, full_list):
    """Handle multiselect updates"""
    for symbol in selected:
        if symbol not in st.session_state.selected_symbols:
            st.session_state.selected_symbols.append(symbol)
    for symbol in full_list:
        if symbol not in selected and symbol in st.session_state.selected_symbols:
            st.session_state.selected_symbols.remove(symbol)

def get_available_assets(timeframe=None):
    """Return hierarchical market structure with nested universes"""
    asset_groups = {}
    if not timeframe:
        return {'Please select timeframe first': []}

    try:
        # Get crypto pairs
        btc_pairs = get_finstore("crypto_binance", timeframe, pair="BTC").read.get_symbol_list()
        usdt_pairs = get_finstore("crypto_binance", timeframe, pair="USDT").read.get_symbol_list()
        asset_groups['Crypto'] = {
            'BTC Pairs': list(btc_pairs) if len(btc_pairs) > 0 else ['No BTC pairs'],
            'USDT Pairs': list(usdt_pairs) if len(usdt_pairs) > 0 else ['No USDT pairs']
        }
    except Exception as e:
        asset_groups['Crypto'] = {'Error': [f'Failed to load crypto data: {str(e)}']}

    try:
        nse_eq = get_finstore("indian_equity", timeframe, pair="").read.get_symbol_list()
        asset_groups['Indian Market'] = {
            'NSE Equity': list(nse_eq) if len(nse_eq) > 0 else ['No NSE equities']
        }
    except Exception as e:
        asset_groups['Indian Market'] = {'Error': [f'Failed to load Indian data: {str(e)}']}

    # Try to get MT5 forex pairs if available
    try:
        from data.fetch.mt5_forex import get_forex_pairs, get_metal_pairs, get_indices
        
        forex_pairs = get_forex_pairs()
        metal_pairs = get_metal_pairs()
        indices = get_indices()
        
        asset_groups['MT5 Forex'] = {
            'Major Pairs': [p for p in forex_pairs if any(major in p for major in ['EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF', 'AUDUSD', 'USDCAD', 'NZDUSD'])][:10] or ['No major pairs'],
            'All Forex': forex_pairs[:20] if forex_pairs else ['No forex pairs available'],
        }
        
        asset_groups['MT5 Metals & Commodities'] = {
            'Precious Metals': metal_pairs[:10] if metal_pairs else ['XAUUSD', 'XAGUSD', 'XPTUSD', 'XPDUSD'],
            'Indices': indices[:10] if indices else ['US30', 'SPX500', 'NAS100', 'GER30']
        }
        
    except Exception as e:
        # Fallback to common MT5 symbols if connection fails
        asset_groups['MT5 Forex'] = {
            'Major Pairs': ['EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF', 'AUDUSD', 'USDCAD', 'NZDUSD'],
            'Minor Pairs': ['EURGBP', 'EURJPY', 'GBPJPY', 'CHFJPY', 'AUDNZD', 'GBPCHF']
        }
        
        asset_groups['MT5 Metals & Commodities'] = {
            'Precious Metals': ['XAUUSD', 'XAGUSD', 'XPTUSD', 'XPDUSD'],
            'Indices': ['US30', 'SPX500', 'NAS100', 'GER30', 'UK100', 'JPN225']
        }

    asset_groups.update({
        'US Market': {
            'NASDAQ': ['AAPL', 'TSLA', 'GOOG'],
            'NYSE': ['IBM', 'BA']
        },
        'Commodities': {
            'Metals': ['GOLD', 'SILVER'],
            'Energy': ['OIL', 'NATURALGAS']
        }
    })
    return asset_groups
# -------------------------------------------------------------------
# Strategy Backtester Page
# -------------------------------------------------------------------
def show_backtester_page():
    st.title("Strategy Backtester üîß")
    st.markdown("---")
    
    # Initialize session state for selected symbols
    if 'selected_symbols' not in st.session_state:
        st.session_state.selected_symbols = []
    
    if "backtester_instance" not in st.session_state:
        st.session_state.backtester_instance = None
    
    if "initialized_strategy" not in st.session_state:
        st.session_state.initialized_strategy = None
    
    # 1. Timeframe Selection
    with st.container():
        col1, col2 = st.columns([1, 2])
        with col1:
            with st.expander("üïí Time Configuration", expanded=True):
                timeframe = st.selectbox(
                    "Timeframe:",
                    options=["1D", "4H", "1H", "15m", "5m", "1m"],
                    index=2
                )
        
        with col2:
            with st.expander("üì¶ Strategy Module Selection", expanded=True):
                strategy_modules = list_strategy_modules()
                selected_module = st.selectbox("Select Strategy Module", options=list(strategy_modules.keys()))
    
    st.markdown("---")
    # 3. Asset Selection
    with st.expander("üåç Asset Universe", expanded=True):
        with st.spinner("Loading Assets..."):
            asset_data = get_available_assets(timeframe)
            tab1, tab2, tab3, tab4, tab5 = st.tabs(["Crypto", "Equities", "MT5 Forex", "MT5 Metals", "Commodities"])
            
            with tab1:
                crypto_selection_widget(asset_data.get('Crypto', {}))
            with tab2:
                equity_selection_widget(asset_data.get('Indian Market', {}), 
                                    asset_data.get('US Market', {}))
            with tab3:
                mt5_forex_selection_widget(asset_data.get('MT5 Forex', {}))
            with tab4:
                mt5_metals_selection_widget(asset_data.get('MT5 Metals & Commodities', {}))
            with tab5:
                commodity_selection_widget(asset_data.get('Commodities', {}))
            
            st.divider()
            display_selected_symbols()
    

    st.markdown("---")
    # 4. Strategy Parameters
    with st.expander("‚öôÔ∏è Strategy Parameters", expanded=True):
        strategy_func = strategy_modules[selected_module]
        sig = inspect.signature(strategy_func.__init__)
        params = {}
        # Skip the first two parameters (ohlcv_data and symbol_list)
        for param in list(sig.parameters.values())[1:]:
            if param.annotation == int:
                val = st.number_input(
                    param.name,
                    value=param.default if param.default != inspect.Parameter.empty else 0,
                    step=1
                )
            elif param.annotation == float:
                val = st.number_input(
                    param.name,
                    value=param.default if param.default != inspect.Parameter.empty else 0.0,
                    step=0.000001
                )
            else:
                val = st.text_input(
                    param.name,
                    value=str(param.default) if param.default != inspect.Parameter.empty else ""
                )
            params[param.name] = val
    
    st.markdown("---")
    # 5. Backtest Configuration
    with st.expander("üìÖ Backtest Settings", expanded=True):
        col1, col2 = st.columns(2)
        with col1:
            start_date = st.date_input("Start Date", value=date(2023, 1, 1))
        with col2:
            end_date = st.date_input("End Date", value=date(2026, 1, 1))
        
        init_cash = st.number_input("Initial Capital", value=100000)
        fees = st.number_input("Trading Fees (%)", step=0.0001, value=0.0005, format="%.6f")
        slippage = st.number_input("Slippage (%)", step=0.0001, value=0.001, format="%.6f")
        size = st.number_input("Size (%)", step=0.01, value=0.01, format="%.6f")
        # Convert the string selection to a boolean
        allow_partial_str = st.selectbox(
            "Allow Partial ? (Usually set True for crypto):",
            options=["True", "False"],
            index=0
        )
        allow_partial = True if allow_partial_str == "True" else False
        cash_sharing_str = st.selectbox(
            "Allow Cash Sharing ? (All assets will share the same cash):",
            options=["True", "False"],
            index=0
        )
        cash_sharing = True if cash_sharing_str == "True" else False

    # 6. Run Backtest
    if st.button("üöÄ Run Backtest", use_container_width=True):
        if not st.session_state.selected_symbols:
            st.error("Please select at least one asset!")
            return
        
        progress_bar = st.progress(0)
        status_text = st.empty()

        def update_progress(progress: int, status: str) -> None:
            status_text.markdown(status)
            progress_bar.progress(progress)
            if progress >= 100:
                progress_bar.empty()
                status_text.empty()
        
        try:
            update_progress(0,"Importing Libraries...")
            from backtest_engine.backtester import Backtester
            update_progress(10, "üìÇ Loading market data...")
            
            strategy_instance = strategy_func(**params)
            
            backtester = Backtester(
                market_name='crypto_binance',
                symbol_list=st.session_state.selected_symbols,
                timeframe=timeframe,
                strategy_object=strategy_instance,
                strategy_type='multi',
                start_date=pd.Timestamp(start_date),
                end_date=pd.Timestamp(end_date),
                init_cash=init_cash,
                fees=fees,
                slippage=slippage,
                size=size,
                cash_sharing=cash_sharing,
                allow_partial=allow_partial,
                progress_callback=update_progress,
                pair='BTC'
            )
            
            pf = backtester.portfolio
            
            update_progress(100, "‚úÖ Backtest completed successfully!")
            
            st.session_state.backtester_instance = backtester
            st.session_state.initialized_strategy = strategy_instance
            st.success("‚úÖ Backtest completed successfully!")
            
        except Exception as e:
            progress_bar.empty()
            st.error(f"‚ùå Backtest failed: {str(e)}")
            import traceback
            print(traceback.print_exc())
            print(e)

        # Assuming 'pf' is the portfolio object generated from your backtest

        with st.spinner("Loading Backtest statistics..."):

            st.subheader("üìä Detailed Portfolio Statistics")
            stats_df = pf.stats().to_frame(name='Value')

            # Convert Timedelta values to strings
            stats_df["Value"] = stats_df["Value"].apply(lambda x: str(x) if isinstance(x, pd.Timedelta) else x)

            st.dataframe(stats_df)

            # --- Equity (PNL) Curve ---
            st.subheader("üìà Equity (PNL) Curve")
            fig_pnl = go.Figure()
            fig_pnl.add_trace(go.Scatter(
                x=pf.value.index, 
                y=pf.value,
                mode='lines',
                name="Portfolio Value"
            ))
            fig_pnl.update_layout(
                yaxis_title="Portfolio Value",
                title="Equity Curve",
                yaxis_type="log" if pf.value.max() > 10000 else "linear"  # Log scale for large values
            )
            st.plotly_chart(fig_pnl)

            # --- Cumulative Returns ---
            st.subheader("üìà Cumulative Returns")
            fig_cum = go.Figure()
            fig_cum.add_trace(go.Scatter(
                x=pf.cumulative_returns.index, 
                y=pf.cumulative_returns,
                mode='lines',
                name="Cumulative Returns"
            ))
            fig_cum.update_layout(
                yaxis_title="Cumulative Returns",
                title="Cumulative Returns Curve",
                yaxis_type="log" if pf.cumulative_returns.max() > 10 else "linear"  # Log scale for large movements
            )
            st.plotly_chart(fig_cum)

            # Returns Overview (pf.returns is a property, not a method)
            st.subheader("üìä Returns Overview")
            returns_series = pf.returns
            returns_df = returns_series.to_frame(name="Returns")
            st.dataframe(returns_df)


            if BACKTEST_BACKEND == 'vectorbtpro':
                st.subheader("üìù Trade History")
                st.dataframe(pf.trade_history)

            # Trade Signals (Records in a human-readable format)
            st.subheader("üìå Trade Signals")
            st.dataframe(pf.trades.records_readable)
        

        with st.spinner("Loading Advanced statistic plots..."):

            if BACKTEST_BACKEND == 'vectorbtpro':
                # Expanding Maximum Favorable Excursion (MFE)
                st.subheader("üìä Expanding MFE")
                fig_mfe = pf.trades.plot_expanding_mfe_returns()
                st.plotly_chart(fig_mfe)

                # Expanding Maximum Adverse Excursion (MAE)
                st.subheader("üìä Expanding MAE")
                fig_mae = pf.trades.plot_expanding_mae_returns()
                st.plotly_chart(fig_mae)

            # Risk-adjusted Metrics: Sharpe & Sortino Ratios
            sharpe_ratio = pf.sharpe_ratio
            sortino_ratio = pf.sortino_ratio
            st.metric(label="üìà Sharpe Ratio", value=f"{int(sharpe_ratio):.2f}")
            st.metric(label="üìà Sortino Ratio", value=f"{int(sortino_ratio):.2f}")

            # Benchmark Comparison (if available)
            if hasattr(pf, 'benchmark_cumulative_returns'):
                st.subheader("üìä Benchmark vs Portfolio Performance")
                st.line_chart(pf.cumulative_returns)
        

    # üìå Save Portfolio with Metadata
    st.subheader("üíæ Save Backtest Portfolio")
    save_filename = st.text_input("Enter filename to save (without extension):", value=f"{selected_module}_{timeframe}_{date.today()}")

    if st.button("Save Portfolio"):
        if st.session_state.backtester_instance is None:
            st.error("‚ùå No portfolio to save! Run a backtest first.")
        else:
            try:
                st.session_state.backtester_instance.save_backtest(save_name = save_filename)

                st.success(f"‚úÖ Portfolio saved successfully as database/backtest/{save_filename}")
            except Exception as e:
                st.error(f"‚ùå Error while saving: {e}")
                import traceback
                print(traceback.print_exc())



    # üîÑ Load Previously Backtested Portfolio
    with st.expander("üìÇ Load Previous Backtest", expanded=False):

        with st.spinner("Loading backtests..."):

            from backtest_engine.backtester import Backtester
            # Fetch available backtests
            backtests = Backtester.list_backtests()

            if not backtests:
                st.info("No saved backtests found. Run and save a backtest first.")
            else:
                selected_backtest = st.selectbox("Select a backtest to view:", list(backtests.keys()))

                if selected_backtest:
                    params = backtests[selected_backtest]

                    col1, col2 = st.columns(2)

                    with col1:
                        st.write(f"**Strategy Name:** {params['strategy_name']}")
                        st.write(f"**Market Name:** {params['market_name']}")
                        st.write(f"**Timeframe:** {params['timeframe']}")
                        st.write(f"**Symbols:** {', '.join(params['symbol_list'])}")
                        st.write(f"**Trading Pair:** {params['pair']}")
                        st.write(f"**Start Date:** {params['start_date']}")
                        st.write(f"**End Date:** {params['end_date']}")

                    with col2:
                        st.write(f"**Initial Cash:** ${params['init_cash']:,.2f}")
                        st.write(f"**Trading Fees:** {params['fees'] * 100:.4f}%")
                        st.write(f"**Slippage:** {params['slippage'] * 100:.4f}%")
                        st.write(f"**Allow Partial Orders:** {params['allow_partial']}")
                        st.write("**Strategy Parameters:**")
                        st.json(params["strategy_params"])

                    # üìä Performance Metrics
                    st.subheader("üìä Performance Metrics")
                    col1, col2, col3 = st.columns(3)
                    col1.metric(label="üìà Returns", value=f"{params['performance']['returns']:.2%}")
                    col2.metric(label="üìà Sharpe Ratio", value=f"{params['performance']['sharpe_ratio']:.2f}")
                    col3.metric(label="üìâ Max Drawdown", value=f"{params['performance']['max_drawdown']:.2%}")
                    
                    deploy_col1, deploy_col2 = st.columns(2)
                    # üîÑ Load Backtest Button
                    if deploy_col1.button("üîç Load Portfolio & Stats"):
                        with st.spinner("Loading backtest..."):
                            pf, _ = Backtester.load_backtest(selected_backtest)  # Load portfolio

                        # ‚úÖ Success message
                        st.success(f"Successfully loaded backtest: {selected_backtest}")

                        # üìä Display Portfolio Statistics
                        st.subheader("üìä Portfolio Statistics")
                        stats_df = pf.stats().to_frame(name="Value")

                        # Convert Timedelta values to readable format
                        stats_df["Value"] = stats_df["Value"].apply(lambda x: str(x) if isinstance(x, pd.Timedelta) else x)

                        st.dataframe(stats_df)

                        # --- üìà Equity (PNL) Curve ---
                        st.subheader("üìà Equity (PNL) Curve")
                        fig_pnl = go.Figure()
                        fig_pnl.add_trace(go.Scatter(
                            x=pf.value.index, 
                            y=pf.value,
                            mode='lines',
                            name="Portfolio Value"
                        ))
                        fig_pnl.update_layout(
                            yaxis_title="Portfolio Value",
                            title="Equity Curve",
                            yaxis_type="log" if pf.value.max() > 10000 else "linear"
                        )
                        st.plotly_chart(fig_pnl)

                        # --- üìà Cumulative Returns ---
                        st.subheader("üìà Cumulative Returns")
                        fig_cum = go.Figure()
                        fig_cum.add_trace(go.Scatter(
                            x=pf.cumulative_returns.index, 
                            y=pf.cumulative_returns,
                            mode='lines',
                            name="Cumulative Returns"
                        ))
                        fig_cum.update_layout(
                            yaxis_title="Cumulative Returns",
                            title="Cumulative Returns Curve",
                            yaxis_type="log" if pf.cumulative_returns.max() > 10 else "linear"
                        )
                        st.plotly_chart(fig_cum)

                        # üìä Returns Overview
                        st.subheader("üìä Returns Overview")
                        returns_df = pf.returns.to_frame(name="Returns")
                        st.dataframe(returns_df)

                        if BACKTEST_BACKEND == 'vectorbtpro':
                            st.subheader("üìù Trade History")
                            st.dataframe(pf.trade_history)

                        # Trade Signals (Records in a human-readable format)
                        st.subheader("üìå Trade Signals")
                        st.dataframe(pf.trades.records_readable)

                        # üîç Advanced Metrics & Risk Analysis
                        with st.spinner("Loading Advanced Statistics..."):

                            if BACKTEST_BACKEND == 'vectorbtpro':
                                # Expanding Maximum Favorable Excursion (MFE)
                                st.subheader("üìä Expanding MFE")
                                fig_mfe = pf.trades.plot_expanding_mfe_returns()
                                st.plotly_chart(fig_mfe)

                                # Expanding Maximum Adverse Excursion (MAE)
                                st.subheader("üìä Expanding MAE")
                                fig_mae = pf.trades.plot_expanding_mae_returns()
                                st.plotly_chart(fig_mae)

                            # üìà Risk-adjusted Metrics: Sharpe & Sortino Ratios
                            sharpe_ratio = pf.sharpe_ratio
                            sortino_ratio = pf.sortino_ratio
                            st.metric(label="üìà Sharpe Ratio", value=f"{sharpe_ratio:.2f}")
                            st.metric(label="üìà Sortino Ratio", value=f"{sortino_ratio:.2f}")

                            # üìä Benchmark Comparison (if available)
                            if hasattr(pf, 'benchmark_cumulative_returns'):
                                st.subheader("üìä Benchmark vs Portfolio Performance")
                                st.line_chart(pf.cumulative_returns)

                    if deploy_col2.button("üöÄ Deploy Strategy"):
                        # Get backtest UUID and parameters
                        backtest_uuid = selected_backtest
                        params = backtests[selected_backtest]
                        
                        # Generate URL parameters for deployment dashboard
                        deploy_params = {
                            'backtest_uuid': backtest_uuid
                        }
                        
                        query_string = urlencode(deploy_params)

                        js = f"""
                                <script>
                                    // Get the full URL
                                    var fullUrl = window.location.href;

                                    // Extract base path by removing everything after the last '/'
                                    var basePath = fullUrl.substring(0, fullUrl.lastIndexOf('/'));

                                    // Construct the deployment URL
                                    var deployUrl = basePath + "/strategy_deployment?{query_string}";

                                    // Open in a new tab
                                    window.open(deployUrl, "_blank");
                                </script>
                            """

                        # Execute JavaScript in Streamlit
                        st.components.v1.html(js, height=0)


# Run the page
show_backtester_page()